{\rtf1\ansi\ansicpg1252\cocoartf1348\cocoasubrtf170
{\fonttbl\f0\fnil\fcharset0 Lato-Regular;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww11980\viewh16580\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\fs28 \cf0 /* \
\
INITIAL LOADING OF LEARN MODE\
\
Need to request to GET the current sequence from the user_id and the set_id. If there is no current sequence, or if the last sequence was completed (error check because we should always create a new sequence after finishing previous) then we will POST a new sequence with user_id, set_id, mode, format, timing and difficulty. For the difficulty, check the assignment of the user & set. If no assignment, use intermediate default. \
\
Once we get the sequence, which has the current position variable, we will dispatch the data to the redux store. We can also use the nested set object in the sequence to display the title in the header component. \
\
Once we have the sequence object, with its id, position and length we can begin filling in the redux store. We can also fill the store with the set object and the user object (even though this theoretically could come from the user store).\
\
If we have the sequence ID that we're looking for, then we can concurrently call to get all of the slots for that sequence. So this is a separate function that will use async to get all slots, but can happen at same time in axios.all call.  \
\
The slots will be a list of objects that will help us fill our sign posting in terms of colors and length. Each slot will serve to give us the cue/target, and all the help that is avail. We will need helper functions to crawl through the current slot object to determine which hint or which format we are going to use next. \
\
We will gather this list of slots and in order to filter/find the current slot, we will just use the current position specified by redux store (aka sequence). The current slot will tell us whether the user can most importantly 1) click to answer, 2) has hints avail and 3) what the current level/format they are on. We can choose to show the original cue which is in the nested item object, or we can show the censored_cue in the slot. \
\
We will need specific methods for a) adapting upon wrong answer b) showing hint upon user click and c) showing correct answer upon optimistic grading / PUT response \
\
Once we get the current slot object, we will GET all of the trials at /slots/slot:id/trials. We will filter to the last incomplete trial and note which format it was left at. Immediately call for a new trial, with the DateTime for the start key. \
\
To POST a new trial, we need to know the slot_id, visible or shown_cue, the format last used in slot/last_trial, and some other values provided by the slot or sequence. We can simultaneously show the cue to the user, POST this trial and further wait for response. This should all happen in same time to keep start time consistent. \
\
Upon a successful POST to the trial, store the response data in the store in the current_trial. Wait for user action. They can navigate away (how do we determine??), answer incorrectly, answer correctly or seek a hint. Each of these well defined actions can either use one action passing in different arguments or have well-defined functions for themselves. Or pass through one parent method and then get sent to other helper functions. \
\
When a user takes action, we are making a PUT to that trial, with the reaction_time, response_time, answer (if there is any). If the user clicks HINT, that creates a new trial (POST) with the next augmentation/hint in our slot bucket. On this POST, need to specify that the user took action to receive help. *Check the non-bolded content in the docs*. But specifying the help/format displayed will be sent in the POST request. \
\
\'97 \
\
Next steps\'85 CHECKING ACCURACY\
\
\
Once the initial calls have been made and the store is loaded with sequence and slots, then its just a matter of POSTing new trials, PUTting to those trials and then displaying meaningful information or adjusting the difficulty. *Key here: have a helper function that looks at next best format option and boom, POSTS new trial. So the methodology is POST new trial, user responds poorly, PUT to the trial, on response of PUT check the accuracy. If the accuracy was 1, PUT to that slot it is complete and show correct message. If the answer !== 1, then POST a new trial, passing the current trial through the helper function that looks at available diff/hints/format in the slot. \
\
If the completion of the slot !== \'91None\'92, and the display message on view says \'91Press any key to continue\'92, then when the clicks key and calls that function, load the next slot in the store, POST a new trial with available information using store and concurrently display whatever that info is. We should be using the redux store more here to facilitate updating the view. Don\'92t rely on successful POSTS/PUTS to update the store and thus the view. POST to the server saying, \'91This is what we\'92re showing! Get ready for response in PUT format!\'94 \
\
When moving from slot to slot, make sure to update the position in the sequence using PUT. When completing a slot, make a PUT to that slot. When all slots have finished (helper check/method), PUT to the sequence that its complete. Upon any action, whether user navigating or clicking any button, POST a new sequence. \
\
\'97\
\
Secondary steps\'85 5_SLOT_GROUPS\
\
In order to display five items at a time, need a function that splits the sequence into meaningful 5 slots at a time. \
\
Would need to always split at 5, and need a way to come back to that same five next time. We would need a second object key for 5_slot_sequence that updates based from parent sequence. To determine what 5_slot we\'92re at, we would need to loop over/filter the slots to an array of arrays. Each new array would have a key for its completion or not (whether all slots within it have been completed), and then when loading a new sequence, we would load whichever slot hasn\'92t been completed. Might even run two functions at once, POPPING off any slot group that was completed, in order to not interfere with process. \
\
\
/*}